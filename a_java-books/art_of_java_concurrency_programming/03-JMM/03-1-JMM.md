# Java 内存模型
* 多线程并发编程中的两个关键问题：
* * 线程通信
```md
  指线程之间交换信息。
  在命令式编程中，线程间的通信机制分为两种：共享内存 和 消息传递。
```
* * 线程同步
```md
  指程序中用于控制不同线程间操作发生顺序的机制。
```
*  并发模型
* * 共享内存并发模型
```md
线程之间共享程序运行的公共状态，通过读写内存中的公共状态进行隐式通信。
在共享内存模型中，同步是显式进行的，程序员必须显式地指定某个方法或某段代码需要再线程之间互斥执行。
```
* * 消息传递并发模型
```md
线程之间通过发送消息显式地进行通信。
在消息传递模型中，由于消息的发送必须在消息接受之前，因此同步是隐式进行的。
```
* * Java 的并发模型
```md
Java 采用多线程并发的共享内存模型，线程之间的通信总是隐式进行，整个通信的过程对程序员完全透明。
但程序员需要了解线程之间隐式通信的工作机制，否则会遇到各种内存可见性问题。
另外，线程的同步需要由程序员来实现。
```
## JMM的抽象结构
```md
实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。
（所以，一般共享变量是指 实例域、静态域和数组元素）

局部变量，方法定义参数（Formal Method Parameters）和异常处理器（Exception Handler Parameters）
不会线程之间共享，他们不会存在内存可见性问题，也不受内存模型的影响。

Java 线程之间的通信有JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。
从抽象角度来看，JMM定义了线程和主内存之间的抽象关系：
即线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，
```
* 本地内存
```md
本地内存中存储了该线程读写共享变量的副本。
本地内存是JMM的一个抽象概念，实际并不存在。
它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。
```

![JMM 抽象结构](../00-pic/JMM-abstract-struct.jpg)

```md
线程A 与 B的通信必须经历以下两个步骤：
1. 线程A 把本地内存中A更新过的共享变量刷新至主内存中，
2. 线程B 到主内存中读取已经更新的变量。
```
```md
JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性的保证。
```
## 从源代码到指令序列的重排序
> 参考 [重排序](03-2-reorder.md)

## 并发编程模型的分类
```md
现在处理器使用写缓冲区临时保存向内存写入的数据，
写缓冲区可以保证指令流水线持续运行，可以避免处理器等待向内存写入数据产生的延迟。
同时，通过批处理方式刷新写缓冲区，已经合并写缓冲区中对同一内存地址的多次写，减少堆内存总线的占用。

但是每个处理器的写缓冲区，仅对它所在的处理器可见。
这会对内存操作的执行顺序产生重要影响：
处理器对内存的读写操作的执行顺序，不一定和内存实际发生的读写操作顺序一致。
```

## happens-before 简介
> 参考 [happens-before](03-07-happens-before.md)