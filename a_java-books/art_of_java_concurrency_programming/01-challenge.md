# 并发编程的挑战
```md
并发编程的目的是为了让程序运行更快，但并不是启动更多的线程就能让程序跑的更快。
```
## 上下文切换
```md
即使是单核处理器也支持多线程并发，CPU通过时间片轮转来实现这个机制。
时间片是分配给各个线程的执行时间，时间片非常短，CPU通过不停切换线程执行，
让多个线程同时执行，时间片一般是 几十 ms。

在任务切换时，需要保存上一个任务的执行状态，以便下次切换回这个任务时可以继续执行。
任务从保存到加载的过程就是一次上下文切换。

这样的切换是会影响多线程的执行速度的。
```
### 多线程一定快吗？
```md
和程序的规模有关系，当任务量不是很大时，多线程的效果就不明显，甚至会比单线程更慢，
因为线程由创建和上下文切换的开销。
```
### 测试上下文切换时长和次数
* Lmbench3 测量上下文切换时长 
> [LMbench - Tools for Performance Analysis](http://www.bitmover.com/lmbench/)
* vmstat 测量上下文切换次数
```sh
$ vmstat  1
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 6  1 11919912 154876768  40180 11693276    0    0     4    61    0    0 15 11 74  0  0
67  3 11919912 154870160  40180 11693684    0    0     0   276 144904 237570  6 31 62  1  0
 4  0 11919912 154874048  40180 11694060    0    0     0  1604 128353 211280  5 25 69  0  0
 5  0 11919912 154862528  40180 11694452    0    0     0   516 130195 215469  6 31 62  1  0
 ... ...
```
* * CS（Content Switch）
```md
表示上下文切换次数，上面输出可以看出每s切换20多万次。
```
### 如何减少上下文切换？
* 无锁并发编程
```md
多线程竞争时，会引起上下文切换。所以可以采用一些方法来避免使用锁。
如将数据的ID按照HASH算法取模分段，不同的线程处理不同段的数据。
```
* CAS 算法
```md
Java的Atomic 包使用 CAS 算法来更新数据，而不需要加锁。
```
* 使用最少线程
```md
避免创建不必要的线程。
```
* 协程
```md
在单线程里实现多任务的协调，并在单线程里为此多个任务间的切换。
```
### 减少上下文切换实战
> 示例 ： 通过减少线上大量WAITING 线程，来减少上下文切换
* 第一步 jstack dump 线程信息 看看 进程里的线程都在做什么
```sh
$ jstack 12443  > 12443.jstack.dump
```
* 第二步 统计线程状态
```sh
$ fgrep  java.lang.Thread.State 12443.jstack.dump | awk '{print $2$3$4$5}' | sort | uniq -c
      3 BLOCKED(onobjectmonitor)
     45 RUNNABLE
      1 TIMED_WAITING(onobjectmonitor)
     38 TIMED_WAITING(parking)
      2 TIMED_WAITING(sleeping)
    394 WAITING(onobjectmonitor)
    183 WAITING(parking)
```
```
第一步和第二步也可以使用以下命令：
$ jstack pid | fgrep  java.lang.Thread.State | awk '{print $2$3$4$5}' | sort | uniq -c
```
* 第三步 打开dump文件查看WAITING（onobjectmonitor）的线程在做什么
* 第四步 如果是线程池配置线程数过多，可以适当降低 maxThreads
* 第五步 调整后，需要重新确认。
  重新统计 WAITING(onobjectmonitor) 线程数。
  也可以看下 上下文切换 次数是否减少了。

## 死锁
```md
线程死锁只线程相互等待对方释放锁。

现实中比较常见的一种情况是，程序出现了异常而没有释放锁。
一旦出现死锁，业务是可感知的，因为不能继续提供服务了，那么可以通过dump线程来查看是哪个线程的问题。
```
* 避免死锁的方法
```md
1. 避免一个线程同时获取多个锁
2. 避免一个线程在锁内同时占用多个资源
3. 尝试使用锁超时
4. 对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况。
```
## 资源的限制
* 什么是资源限制
```md
指的是在进行并发编程时，程序的执行速度受限于计算机硬件或软件资源。
硬件资源限制 有带宽的上传/下载速度、磁盘读写速度、CPU处理速度。
软件资源限制 有 数据库的连接数、socket 连接数等。
```
* 资源限制引发的问题
```md
如果资源受限，多线程执行可能会退化为单线程，程序不仅不会加快，可能更慢，
因为增加了上下问切换和资源调度的时间。
```
* 如何解决资源限制的问题
```md
对于硬件资源的限制，可以考虑采用集群化。
对于软件资源的限制，可以考虑资源池来复用资源。
```
* 在资源限制情况下进行并发编程
> 如何在资源限制的情况，使得程序执行更快？
```md
根据不同的资源限制调整程序的并发数。

比如下载文件程序依赖 带宽 和 磁盘读写 速度。
数据库 涉及数据库连接数，如果SQL语句执行够快，而线程的数量比数据库连接数还多，
则某些线程会被阻塞，等待数据库连接。
```