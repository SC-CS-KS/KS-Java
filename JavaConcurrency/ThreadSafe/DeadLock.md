# DeadLock  

```
若干进程竞争有限资源，又推进顺序不当，从而构成无限期循环等待的局面
	简单一点描述，死锁是指多个进程循环等待它方占有的资源而无限期地僵持下去的局面
很显然，如果没有外力的作用，那么死锁涉及到的各个进程都将永远处于封锁状态。

银行家算法
	死锁是操作系统层面的一个错误，是进程死锁的简称
		最早在 1965 年由 Dijkstra 在研究银行家算法时提出的
```

* 条件  
  
```
	互斥条件
	请求与保持条件
	不剥夺条件
	循环等待条件
```

* 解决方案  
```
	一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。
```

* 场景  
```
	锁顺序死锁
	动态锁顺序死锁
	协作对象之间发生死锁
```

* 避免死锁  

```
	避免一个线程同时获得多个锁
	避免一个线程在锁内部占有多个资源
		尽量保证每个锁只占用一个资源
	固定锁顺序避免死锁
	开放调用避免死锁
		如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用
		同步代码块最好仅被用于保护那些涉及共享状态的操作
	尝试使用定时锁，使用lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞
	对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
```

* 死锁检测  

```
		ThreadMXBean类
			Java 5引入了ThreadMXBean接口
				它提供了多种监视线程的方法
			findDeadlockedThreads
	JDK
		JconsoleJDK自带的图形化界面工具，使用JDK给我们的的工具JConsole
		Jstack是JDK自带的命令行工具，主要用于线程Dump分析。
```

## Reference  

* [多线程之死锁](https://www.cnblogs.com/Java3y/p/8999199.html)