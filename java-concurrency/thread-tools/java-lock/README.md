# Java Lock

## JVM 锁机制

## [对象锁](Object-Lock.md)
* 重量级锁

* 自旋锁(Spin Lock)
```md
自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看看这段时间有没其他人把这锁给释放了。
```

* 自适应自旋锁
```md
能够根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为自适应自旋锁。
```

* 轻量级锁
```md
当进入一个方法的时候根本就不用加锁，只需要做一个标记就可以了，也就是说，可以用一个变量来记录此时该方法是否有人在执行。
也就是说，如果这个方法没人在执行，当进入这个方法的时候，采用CAS机制，把这个方法的状态标记为已经有人在执行，
退出这个方法时，再把这个状态改为了没有人在执行了。
```
```md
如果真的遇到了竞争，就会认为轻量级锁已经不适合了，就会把轻量级锁升级为重量级锁了。
```
* 偏向锁

## 悲观锁和乐观锁
```md
重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为悲观锁。
```
```md
乐观锁却相反，认为不加锁也没事，可以先不加锁，如果出现了冲突，我们在想办法解决，
例如 CAS 机制，上面说的轻量级锁，就是乐观锁的。
不会马上加锁，而是等待真的出现了冲突，在想办法解决。
```

## 公平锁 和 非公平锁
```md
线程获取锁是否公平，是指线程是否能够按照申请加锁的顺序来获得锁。

如果一个线程申请锁时，会判断AQS队列中是否有等待线程，如果有，则入队等待，
当持有锁的线程释放锁时，处于队头的等待线程会获得锁，此时就是 公平锁策略。

如果一个线程申请锁时，有可能先于AQS队列中的等待线程先获得锁，
则此时实现的是 非公平锁 策略。
```
```java
ReentrantLock lock = new ReentrantLock() // 非公平锁
ReentrantLock lock = new ReentrantLock(true) // 公平锁

JUC 很多锁默认的策略都是非公平的。
```

## [死锁](DeadLock.md)
