# 线程调优
## 性能指标
* 单线程
```md
单线程情况下，服务接收到请求后开始初始化，资源准备，计算，返回结果，
时间主要花在CPU计算和CPU外的IO等待时间，多个请求来也只能排队一个一个来。

RT = T(cpu) + T(io)
QPS = 1000ms / RT
```
* 多线程
> * 最佳并发量 计算
```md
单核情况：N = [T(cpu) + T(io)] / T(cpu)
M核情况：N = [T(cpu) + T(io)] / T(cpu) * M
(N 为线程数)

由于多核情况CPU未必能全部使用，存在一个资源利用百分比P
那么并发的最佳线程数 N = [T(cpu) + T(io)] / T(cpu) M P
```
* 吞吐量
> * 多线程的QPS
```md
QPS = 1000ms / RT N = 1000ms / T(cpu) + T(io) [T(cpu) + T(io)] / T(cpu) M P = 1000ms / T(cpu) M P
```
## 锁优化
* 时间
```md
既然我们并不喜欢锁，那么就按需索取，只在核心的同步块加锁，用完立马释放，
减少锁定临界区的时间，这样就可以把资源竞争的风险降到最低。
```
* 粒度
> * 锁分离
```md
有时候我们核心同步块可以进一步分离，比如只读的情况下并不需要加锁，这时候就可以用读写锁各自的读写功能。
```
> * 锁粗化
```md
有时候我们反而会小心翼翼的到处加锁来防止意外出现，
可能出现三个同步块加了三个锁，这也造成CPU的过多停顿，根据业务其实可以把相关逻辑合并起来，也就是锁粗化。
```
* 尺度
```md
除了锁暂用时间和粒度外，还有就是锁的尺度，还是根据业务来，能用共享锁定的情况就不要用独享锁。
```
* 死锁

## 无锁
* CAS策略




