# 内部类

Inner Classes 不能定义为static，不能有static方法和static初始化语句块。

在JLS（java语言规范）里面是这么定义的
	An inner class is a nested class that is not explicitly or implicitly declared static.
	 Inner classes may not declare static initializers (§8.7) or member inter- faces.

内部类是依附于外围类而存在的，可以自由使用外部类的所有变量和方法，innerClass内部可以随意访问OuterClass中的private属性。
其实也就是内部类存在着指向外围类的引用。

## inner member classes

没有用 static 修饰的成员内部类。

### 访问规则：
	inner member classes（内部成员类） 可以访问外部类的所有实例属性，静态属性
		因为内部成员类持有一个外部对象的引用，内部类的实例可以对外部类的实例属性进行修改
	如果是public的 inner  member classes
		可以通过 外部类实例.new 内部类()的方式进行创建

## local inner classes

嵌套在方法里或者是某个作用域内，通常情况下不希望这个类是公共可用的，
相比于成员内部类，局部内部类的作用域更加狭小了，除了方法或者作用域就无法被访问。

一般用于在内部实现一些私有的辅助功能。
定义在方法里面的内部类，方法可以是static的也可以是非static的，也可以是构造器方法。
局部类不能有访问控制符(private,public,protected修饰），可以是抽象的，也可以定义为final。

### 访问规则

定义在static上下文（static 字段初始化，static初始化块，static方法）里面的local inner classes 可以访问类的静态属性。
如果定义在静态方法里面的局部类，还可以方法里面定义的final变量。
在static上下文定义的局部类，必须没有指向父类实例变量的引用。
而且局部类不能在外部进行创建，只能在方法调用的时候进行创建。

## anonymous inner classes

[详解匿名内部类](https://www.cnblogs.com/chenssy/p/3390871.html)

匿名内部类也就是没有名字的内部类
	正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写
	但使用匿名内部类还有个前提条件：必须继承一个父类或实现一个接口

### 类初始化

匿名内部类是没有构造器
	用构造代码块能够达到为匿名内部类创建一个构造器的效果

### 注意

使用匿名内部类时，我们必须是继承一个类或者实现一个接口
	但是两者不可兼得，同时也只能继承一个类或者实现一个接口。
匿名内部类中是不能定义构造函数的
匿名内部类中不能存在任何的静态成员变量和静态方法
匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效
匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法
给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final
	在内部类编译成功后，它会产生一个class文件
		该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。
	内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份
	在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是
		也就是说在内部类中对属性的改变并不会影响到外部的形参
			而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个
			如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的
		所以为了保持参数的一致性，就规定使用final来避免形参的不改变

### 场景

[匿名内部类的使用场景](https://blog.csdn.net/bujiangjiu17/article/details/78449262)
当某个类除了它的外部类，不再被其他的类使用时
解决一些非面向对象的语句块
一些多算法场合
适当使用内部类，使得代码更加灵活和富有扩展性

当我们需要快速创建多个Thread的时候，经常会使用到它。

## 与 OuterClass

OuterClass.this
	内部类和外围类的联系是通过内部类所持有的外部类的引用来实现的
	想要获取这个引用，可以使用外围类的.this来实现

## 实例化
```java
InnerClass inner = new OuterClass().new InnerClass();
```
## 场景

### 实现多重继承

《Thinking in Java》:
每个内部类都能独立地继承一个（接口的）实现
	所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

## 总结

《Think in Java》
```text
	内部类可以用多个实例
		每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
	在单个外围类中
		可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
	创建内部类对象的时刻并不依赖于外围类对象的创建。
	内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
	内部类提供了更好的封装，除了该外围类，其他类都不能访问。
```

## 与闭包

[Java 内部类与闭包](https://juejin.im/post/5b70db05e51d4566381883a1)

