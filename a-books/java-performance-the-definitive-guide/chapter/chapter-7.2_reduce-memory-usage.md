## 减少内存使用
```md
堆内存使用越少，堆被填满的机会就越小，需要的GC周期越少。
而且有倍乘效应：
新生代回收次数更少，对象的晋升年龄也就不会频繁的增加，
意味着对象被提升到老年代的可能性降低，因此 Full GC 也会减少。
而且 如果这些 Full GC 能清理更多的内存，它们发生的频次也会降低。
```
### 减少对象大小
```md
最简单的减少内存使用的方式就是让对象小一些。
堆中一半的对象的大小减少 20%，就可以达到增加 10% 堆空间的效果。
```
* 两种方式：
```md
* 减少实例对象个数（效果很明显）
* 减少实例变量的大小
```

* 对象头字段
```md
对于普通对象，对象头字段在32位JVM上占 8 字节，64位JVM占16字节。
对于数组，在32位JVM 以及 堆小于32GB的64位JVM上占 16字节，其他情况下占 64字节。
```
* 实例
```java
public class A {
  private int i;
}

public class B {
  private int i;
  private Locale i =  Local.us;
}

public class c {
  private int i;
  private ConcurrentHashMap = new ConcurrentHashMap();
}
```
```md
          Shallow Size  Deep Size   Retained Size
Class A   16            16          16
Class B   24            216         24
Class C   24            200         200

在 Class B中，Locale 变量的定义 将对象的大小增加了 8字节。实际的 Locale 对象是共享的。
如果从来没使用这个对象，就会浪费引用占用的空间，如果创建了大量B的实例，会积少成多。
Class C 中创建了 ConcurrentHashMap，这个对象会增加 200字节。

仅定义需要的实例变量，是节省对象空间的一种方式，还有一种不明显的方式，就是使用更小的数据类型。
特别是在那些频繁实例化的类中，Chapter 12 中会讨论 使用适当大小的 集合类可以达到类似效果。
```
* 对象对齐 和 对象大小
```md
JVM 会填充字节不规则的对象，这样不管底层架构最适合什么样的地址边界，对象的数组都能优雅地适应。
为使对象大小是 8字节的整数倍（对齐），总是会有填充操作。

如果Class A中没有定义 i，A的实例仍然会消耗 16字节，其中4字节用于填充。
而Class B 没有i的话，此时B中仅包含 一个 4字节的引用，会消耗16字节。

所以，去掉某个实例字段或者减少某个字段大小，未必能带来减少内存使用的效果，
不过我们没理由不这么。
```
* 空间 与 时间
```md
* 有些字段会保存基于一些数据计算的结果，该如何处理？
实际上这是典型的时间空间权衡问题：是花费空间保存这个值，还是花时间（CPU周期）重新计算？
（在Java 中可能还需考虑额外的内存占用引发GC带来的CPU周期占用）

* 实例
String 的HashCode 
是对一个涉及该字符串中每个字符的式子求和计算而来的，计算会消耗一点时间。
因此String 类把这个值保存在一个实例变量中，与不存储节省的空间相比，重用几乎总能获得更好的性能。

toString 方法
不会把字符串表示保存在实例变量中，因为引用的字符串会消耗内存。
与保存一个字符串引用相比，计算一个新的字符串所花费的时间通常不多，性能更好。
（另外，HashCode 的使用频率要远高于 toString）
```

* 小结
```md
1. 减少对象大小往往可以改进GC
2. 对象内部即使为 null 的实例变量，也会占用空间。
```
### 延迟初始化
```md

```
### 不可变对象 和 标准化对象
```md

```
### 字符串的保留
```md

```