# Java 并发机制的底层实现原理
```md
Java 并发机制依赖于 JVM 的实现和 CPU 的指令。
```
## volatile 的应用
```md
volatile 是轻量级的 synchronized，在多处理器开发中保证“可见性”。
如果 volatile 变量修饰符使用恰当的话， 比 synchronized 使用成本更低，
因为它不会引起线程的上下文切换和调度。 
```
### volatile 的定义与实现原理
* Java 语言规范第3版 定义
```md
为了确保共享变量能被准确和一直到更新，线程应该确保通过排它锁单独获得这个变量。
Java 语言提供了 volatile，在某些情况下比锁更方便。
如果一个变量被声明为 volatile，JMM 会确保所有线程读同一时间取到这个变量的值是一致的。
```

> 首先了解 [CPU 相关术语](../00-refer/CPU-terms.md)
```md
为了提高处理速度，处理器一般不直接和内存通信，而是先将内存的数据读取到内部缓存后再进行操作，
但操作完不知道何时数据才会写回内存。
```
* volatile 如何保证可见性？
```md
如果对volatile声明的变量做了写操作，JVM 会向处理器发送一条Lock前缀指令。
（将Java 代码转换成汇编代码可以 发现会生成两条指令，第二行为一条Lock前缀的指令）

* Lock 指令
在IA-32 架构软件开发者手册中描述，Lock前缀的指令在多核处理器下会引发两件事情：
1. 将当前处理器缓存行的数据写回内存。
2. 这个写回操作会使得其他CPU里缓存该内存地址的数据无效。

* CPU 缓存失效的实现
在多处理器下，为了保证各个处理器的缓存一致，就会需要实现缓存一致性协议。
每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，
当处理器发现自己的缓存行对应的内存地址的数据被修改，就会将缓存行 设置成无效状态，
当处理器再操作这个数据时，会重新从内存加载。
```
* volatile 的实现原则
```md
1. Lock前缀指令会引擎处理器缓存写回内存。
  Lock前缀指令导致在执行指令期间，声言处理器 LOCK#信号。
  在多处理器环境下 LOCK#信号 确保在声言该信号期间，处理器可以独占任何共享内存。
  但是在最近的处理器里，LOCK#信号一般锁缓存（“缓存锁定”），而不是锁总线，毕竟锁总线的代价太大。
  缓存一致性会确保修改的原子性，也会阻止同时修改由两个处理器缓存的内存区域数据。
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效。
  IA-32 和 Intel 处理器 使用 MESI（修改、独占、共享、无效）控制协议维护缓存一致性。
  处理器使用嗅探技术保证它内部的缓存、系统内存和其他处理器缓存的数据在总线上保持一致。
  嗅探处理器如果发现其他处理器打算写内存地址，而这个地址处于共享状态，那么会使这个缓存行无效，
  下次访问这个内存地址时，强制执行缓存行填充。
```
### volatile 的使用优化
* JUC - LinkedTransferQueue
```md
LinkedTransferQueue JDK 7 新增，采用追加字节的方式来优化队列出队和入队的性能。

采用 PaddedAtomicReference 将 将共享变量追加到64 字节，对于高速缓存行是 64 个字节宽的
处理器，不支持部分填充缓存行，意味着如果队列的头节点和尾节点都不足64字节的话，
处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器会缓存同样的头尾节点，
当一个处理器试图修改一个头节点，会将整个缓存行锁定，会导致其他处理器不能访问自己缓存中的尾节点。
而队列的出队和入队操作则需要不断的修改头尾节点。

不过这种 追加字节的方式在Java 7中可能无效，因为编译器可能会淘汰或重写排列无用字段。
```
* 什么 不能使用 Padded的编程技巧
```md
1. 缓存行 非 64 字节宽的处理器
2. 共享变量不会被频繁的读写
```

* Sunny's Remarks
```md
Padded的编程技巧主要是解决多核之间由于cache length导致的CPU之间通信风暴的问题。
```
```md
Java 8 版本已经LinkedTransferQueue 的实现已经不再采用 PaddedAtomicReference 方式。

    /** head of the queue; null until first enqueue */
    transient volatile Node head;

    /** tail of the queue; null until first append */
    private transient volatile Node tail;
```
> 可以参考阅读
* [伪共享（false sharing），并发编程无声的性能杀手](http://www.cnblogs.com/cyfonly/p/5800758.html)
* [Padded优化LinkedTransferQue并发性能是错误方向](https://my.oschina.net/wenshao/blog/90508?p=2)
