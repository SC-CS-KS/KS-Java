# 重排序
> 重排序是编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段。
* 重排序类型
```md
1. 编译器优化重排序
  编译器在不改变单线程程序语义的情况下，可以重写安排语句的执行顺序。
2. 指令级并行的重排序
  现代处理器采用指令级并行技术（ILP，Instruction-Level Parallelism）将多条指令并行执行。
  如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序
  由于处理器 使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是乱序执行。

1 属于 编译器重排序， 2、3 属于 处理器重排序。
```
* 指令序列的重排序
> 从Java源代码到最终实际执行的指令序列，最终会经历以下过程的重排序
```md
源代码 -> 编译器优化重排序 -> 指令级重排序 -> 内存系统重排序 -> 最终执行的指令序列
```

* 常见处理器的重排序规则
![常见处理器重排序规则](../00-pic/common-cpu-reorder.jpg)
```md
"N" 和 "Y" 表示处理器是否允许两个操作重排序。

常见的处理器都允许“Store-Load”重排序。
常见的处理都不允许对存在数据依赖的操作重排序。

sparc-TSO 和 X86 拥有相对较强的处理器模型，
仅允许对“Store-Load”重排序，因为它们都使用了写缓冲区。

* 注意
sparc-TSO 是指以 TSO（Total Store Order）内存模型运行时 sparc 处理器的特性。
X86 包括 X64 和 AMD64。
```

* 重排序 与 内存可见性
```md
重排序可能会导致多线程程序出现内存可见性问题。

对于编译器，JMM 编译器重排序规则 会禁止特定类型的编译器重排序。
对于处理器重排序，JMM 处理器重排序规则会要求Java 编译器在生成指令序列时，
插入特定类型的内存屏障指令，来禁止特定类型的处理器重排序。

JMM 属于语言级别的内存模型，它确保在不同编译器和不同的处理器平台上，
通过禁止特性类型的重排序，为程序员提供一致的内存可见性保证。
```

* 内存屏障（Memory Barriers，Intel称之为 Memory Fence）
```md
为保证可见性，Java 编译器在生成指令序列的适当位置会插入内存屏障来禁止特性类型重排序。
```
* * 内存屏障类型
```md
* LoadLoad Barriers
Load1;LoadLoad;Load2
确保Load1数据的装载先于Load2以及后续装载指令的执行。

* StroreStore Barriers
Store1;StoreStore;Store2
确保Store1数据对其他处理器可见（刷新到内存）先于Store2及所有后续存储执行的执行。

* LoadStore Barriers
Load1;LoadStore;Store2
确保Load1数据装载先于Store2及所有后续的存储指令刷新到内存。

* StoreLoad Barriers
Store1;StoreLoad;Load2
确保Store1数据对其它处理器可见先于Load2及后续装载指令的执行。
StoreLoad Barriers 会使该屏障之前的所有内存访问指令（Load 和Store）完成之后，
才执行该屏障之后的内存访问指令。

StoreLoad Barriers是一个“全能型”的屏障，同时具有其他3个屏障的效果。
现代的多数处理器支持该屏障。
执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中（Buffer Fully Flush）。
```

## 数据依赖型
```md
如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作就存在数据依赖性。
```
* 数据依赖类型
```md
* 写后读
* 写后写
* 读后写
```
```md
以上三种情况，只要重排序两个操作的执行顺序，程序的执行结果就会被改变。
```
* 保证数据依赖性
```md
编译器和处理器在重排序时，会准守数据依赖性。即不会改变存在数据依赖关系的两个操作的执行顺序。

* 注意
这里的数据依赖性仅针对 单个处理器中执行的指令序列 和 单个线程中执行的操作，
不同处理器之间 和 不同线程之间的 数据依赖性 不被 处理器 和编译器 考虑。
```
## as-if-serial 语义
```md
是指 不管怎么重排序，（单线程）程序的执行结果不会被改变。
编译器、runtime 和 处理器 必须遵循 as-if-serial 语义。
```
```md
as-if-serial 语义把单线程程序保护起来。
遵守 as-if-serial 语义的 编译器、runtime 和 处理器 共同为编程单线程程序的程序员
创建了一个幻觉：单线程程序是按照顺序来执行的。

as-if-serial 语义 使得单线程程序员 无需担心重排序会干扰他们，也无需担心内存可见性问题。
```
## 程序的顺序规则
```md
遵循 happens-before 的程序的顺序规则，即一个线程中的每个操作 happens-before 与该线程中的任意后续操作。
```
```md
在计算机中，软件技术和硬件技术有一个共同的目标：
在不改变程序执行结果的前提下，尽可能提高并行度。
编译器、处理器遵从这个目标，从  happens-before  规则可以看出 JMM 也同样如此。
```
## 重排序对多线程的影响
