# 垃圾收集
```md
垃圾回收的性能由以下基本操作决定：
1. 找到不再使用的对象
2. 回收它们使用的内存
3. 对堆的内存布局进行压缩整理

完成这些操作时，不同的收集器采取了不同的方法，也就表现出了不同的性能特征。
```

* stop the world
```md
GC 回收对象，或者在内存中移动对象时，必须确保应用程序线程不再继续使用这些对象。
这一点在 移动对象时特别重要：
对象的内存地址会发生变化，因此在这个过程中任何应用程序线程都不应该再访问该对象。
所有应用线程停止运行产生的停顿被称为 时空停顿 （stop the world）。

通常这些停顿对性能的影响最大，GC调优时，应尽量减少这种停顿是最为关键的考量因素。
```

## 分代垃圾收集器
* 代 （Generation）
```md
“老年代”（Old Generation 或 Tenured Generation）

“新生代”（Young Generation）
新生代划分为： Eden 空间 和 Survivor 空间。
```

* 分代机制的原因
```md
很多对象的生命周期很短。
```
```java
sum = new BigDecimal(0);
for (StockPrice sp : prices.values()) {
        BigDecimal diff = sp.getClosingPrice().subtract(averagePrice);
        diff = diff.multiply(diff);
        sum = sum.add(diff);
}
```
```md
BigDecimal 是不可变对象，以上这个简单的循环处理一年的股票数据（大约250个循环），
会创建 750 个 BigDecimal 对象，这些对象会在循环的下一个周期开始时被丢弃。
在 add() 方法内，JDK 的库方法 会创建更多类似 BigDecimal 的中间对象。
最终，在一小段代码中，有大量的对象被快速创建和丢弃。
```
```md
Java 中，上述操作是非常普遍的，所以GC的设计就特别需要考虑处理大量（有时候是大多数）的临时对象。
这也是分代设计的初衷之一。
```
* Minor GC
```md
新生代是堆的一部分，对象首先在新生代中分配，当新生代填满时，GC 会暂停所有的应用程序，回收新生代空间。
不在使用的对象会被回收，仍在使用的对象会被移动到其他地方，这种操作被称为“Minor GC”。

* 两个性能上的优势
1. 与处理整个堆相比，只处理新生代更快，意味着更少的停顿时间。
  不过这也意味着应用程序会更频繁的发生停顿，因为JVM 不再等到整个堆填满再GC。
  停顿的次数 和 停顿时间的长短，实际上是一种权衡。
2. 源于新生代中对象的分配方式，对象分配与Eden空间（占据新生代绝大对数）。
  GC 时，Eden 空间的存活对象要么被移动到 Survivor 空间，要么移动到老年代。
  由于所有的对象都被移走，相当于新生代空间自动地做了一次压缩整理。
```
> 所有的GC算法在对 新生代 进行垃圾回收时 都在存在 “stop the world” 现象。

* Full GC
```md
最终老年代也会填满，JVM 需要找出老年代不在使用的对象，并回收。
而是垃圾回收算法差异最大的地方。

简单的垃圾回收算法，直接停掉所有的应用线程，找出不再使用的对象，进行回收。
接着对堆空间进行整理，这个过程被称为“Full GC”。
这通常导致 应用程序长时间的停顿。
```

* Concurrent 垃圾收集器
```md
通过更复杂的计算，还可以再运行线程的同时找出不在使用的对象。CMS 和 G1 收集器 采用这种方式。
由于不停止应用程序，所以被称为“Concurrent 垃圾收集器”。

同时由于它们将停止应用程序的可能降到最小，也被称为“低停顿（Low-Pause）收集器，
有时也称为 无停顿收集器（虽然不太贴切）”。

Concurrent 收集器也使用各种不同的方法对老年代空间进行压缩。

CMS 和 G1 收集器停顿更少，更短，但其代价是消耗更多的CPU。
实际上也可能遭遇长时间的 Full GC 停顿（尽量避免这种停顿，是这些GC的调优算法要考虑的重要方面）
```

* 评估 垃圾收集器
```md
考虑需要达到的整体性能目标。每一个决定都需要权衡取舍。

如果对单个请求的响应时间有要求（如 Java 企业级服务器），你应该考虑一下因素：
* 单个请求会受到停顿时间的影响，受Full GC 的影响会更大。
  如果目标是尽可能缩短响应时间，那么 选择 Concurrent 垃圾收集器 更能合适。
* 如果平均响应时间比最大响应时间更重要（如 90%的响应时间）
  通常采用 Thoughtout 收集器就能满足需求。
* 使用 Concurrent 垃圾收集器 减少停顿的同时，会消耗额外的CPU。

为批量应用选择垃圾回收器可以遵循以下原则：
* 如果 CPU 足够强劲，选择 Concurrent 垃圾收集器 减少 Full GC 产生的停顿。
* 如果 CPU 有限，那么 Concurrent 垃圾收集器 的CPU 消耗会让批量任务消耗更多的时间。
```
## GC 算法
* Serial 垃圾收集器
```md
如果应用运行在 Client 型虚拟机（Windows 平台的32位 JVM 或 运行单处理器的 JVM），
Serial 是默认的垃圾收集器。

使用单线程清理堆的内容。
Minor GC 和 Full GC 都会停止应用程序运行。
Full GC 时会对老年代进行压缩整理。

* 启动
-XX:+UseSerialGC
 
* 关闭
在 Serial 收集器作为默认收集器的系统上，需要关闭只能通过指定另一种收集器来实现。
```
* Throughtput 垃圾收集器
```md
是 Server级收集器（多CPU的Unix机器 以及 任何 64 位虚拟机）的默认收集器。

使用多线程回收新生代空间。
老年代的收集也能使用多线程方式， JDK 7u4 及之后可以开启（-XX:+UseParallelOldGC）这个功能。
(由于使用多线程，也常被称为 Parallel 收集器)

Minor GC 和 Full GC 都会停止应用程序运行。
Full GC 时会对老年代进行压缩整理。

* 启动和关闭
由于在大多数使用场景，它都是默认收集器，所以不需要显式启动。
也可以使用 -XX:+UseParalleGC、-XX:+UseParallelOldGC 标志来启动。
```
* CMS 收集器
```md
设计的初衷是消除 Serial 和 Throughtput 在 Full GC 周期中长时间的停顿。

Minor GC 会暂停应用程序运行，并以多线程方式进行收集。
不同的是，不在使用 Throughtput 的收集算法（-XX:+UseParalleGC），
改用新的算法收集新生代对象（-XX:+UseParNewGC）

Full GC 不需要暂停应用线程，使用若干后台线程定期对老年代空间进行扫描，
即使回收其中不再使用的对象。

这种算法帮助 CMS 成为一个低延时的垃圾回收器：
应用程序只在 Minor GC 和 后台线程扫描 老年代时发生极其短暂的暂停。
停顿的总时长比Throughtput 要短得多。

* 代价
必须要有足够的CPU资源用于运行后台的垃圾收集线程。
后台线程不在进行压缩整理工作，这意味着堆会逐渐的碎片化。

如果CMS 后台线程无法获得足够的CPU 或者 堆变得过度碎片化以至于无法找到连续的空间分配，
CMS 会蜕化到 Serial 收集器的行为：
暂停应用线程，使用单线程回收、整理老年代空间。
再恢复到并发运行，再次启动后台收集线程。

* 启动
-XX:UseConcMarkSweepGC、-XX:+UseParNewGC 标志可以启动 CMS 收集器。
```
* G1 垃圾收集器
```md
设计初衷是 尽量缩短处理超大堆（大于4GB）时产生的停顿。

将堆划分为若干个区域（Region），不过依旧分属于分代收集器。
这些区域中的一部分包含新生代，新生代仍然采用暂停所有应用线程的方式，将存活对象移动到老年代或Survivor。
这些操作是用多线程完成的。

G1是Concurrent 垃圾收集器：
老年代的收集由后台线程完成，大多数工作不需要暂停工作线程。

老年代划分至不同的区域，G1通过将对象从一个区域复制到另一个区域，完成对象的清理工作，
这意味着G1 实现了堆的压缩整理（至少是部分的整理）。因此 G1 的堆不容易发生碎片化（虽然无法完全避免）。

同 CMS 一样，Full GC 需要消耗额外的 CPU 周期：
后台线程必须能够在应用程序线程运行的同时获得足够的CPU运行周期。

* 启动
-XX：UseG1GC 标志可以开启 G1 收集器，默认是关闭的。
```

* 强制 GC
```md
通常情况下 GC 由 JVM 在需要的时触发：
新生代用尽时触发 Minor GC，
老年代用尽时触发 Full GC，或者堆空间即将填满时会触发Concurrent GC（如果情况需要）。

* System.gc()
Java 提供了System.gc() 机制来强制触发GC。

通常情况下，视图通过这种机制显式触发GC不是一个好主意，
会触发 Full GC（即使开启的是 G1 或 CMS），会让应用程序停顿相当长的一段时间。
而且，显式触发GC也不会让应用程序更高效，它会让GC更早开始，但实际只是让性能的影响往后延迟了而已。

默认情况下关闭 System.gc() 的标志 -XX:+DisableExplicitGC 是关闭的，
如有需要可以打开以禁止 应用程序中 错误地调用 System.gc()。

* 应用场景
性能监控或基准测试时。为了更快的预热JVM，在测量周期之前进行一次GC还是有意义的。
类似的还有在做堆分析时，通常在堆转储前做一次Full GC是一个不错的选择，
当然很多的堆转储工具会自动的进行Full GC。

* 其他强制 GC 方法
jcmd <pid> GC.run
jconsole 连接到 JVM，可以再面板触发GC

RMI
作为分布式垃圾收集器的一部分，默认每隔一个小时它会调用 System.gc() 一次。
调用时间可以 系统属性中的 -Dsun.rmi.dgc.server.gcInterval=N 
和 -Dsun.rmi.dgc.client.gcInterval=N 做修改，N单位为毫秒。
Java 7中的默认值是 3 600 000（即一个小时）。
```

## 选择 GC 算法
```md
GC 算法的选择取决于：
1. 应用程序的特征
2. 应用的性能目标

Serial 收集器适用于 内存使用少于 100M的场景。堆很小，Thoughout、CMS、G1 都发挥不了太大作用。
这个Size 准则也限制了 Serial 的使用范畴。
大多数的应用程序在 Throughout 和 Concurrent 收集器之间做选择。
```
* GC 算法 及 批量子任务
```md
对于 批量任务，Throughout Full GC 引入的停顿是主要的考虑。
每个任务的执行都会为总的执行时间增加一部分的延迟时间（elaps time）。
如果每次Full GC 耗时 0.5s，程序5分钟运行时间内需要20个这样的周期，那么性能的损耗高达3.4%。

对于 是否启用 Concurrent 收集器取决于是否有足够的CPU周期用于后台线程的处理。
多个应用线程、多个后台GC线程运行于多个CPU上，如果OS无法满足同时运行这些线程，
那么对CPU的竞争就会反映到应用线程的停顿上。


```
* GC 算法 和 吞吐测试
```md

```
* GC 算法 及 响应时间测试
```md

```
* CMS 和 G1 的抉择
```md
一般情况下，堆空间小于4G时，CMS的性能更好。CMS的算法比较简单，因此在简单的环境中运行的更快。
使用大型堆或巨型堆时，由于G1 可以分割工作，通常表现比CMS要好。

* 模式失效（Concurrent Mode Failure）
CMS 后台线程必须扫描完整个老年代空间，显然花费时间和堆的大小密切相关。
如果堆还未填满之前，就停止了堆的扫描，直接回收了对象，CMS 会发生 模式失效（Concurrent Mode Failure）。
此时 CMS 不得不回退，暂停所有的应用线程，进行Full GC 操作。
这是 处理 Full GC 的仅有唯一的线程，性能损耗非常严重。
随着堆的增大，多个后台线程承担的工作也越多。

G1 把老年代分成不同的区域，使用多个线程分担扫描老年代。
如果后台线程跟不上处理的速度，G1也会发生并发模式失效，但G1 已经使得发生这种状况的几率减小了很多。

* 碎片化
CMS 不对堆进行压缩整理（除非Full GC发生），堆的碎片化也会触发Full GC。
G1 算法随时进行着堆的压缩整理，但仍然可能出现碎片化问题，但G1的设计已经让它领先于CMS一步。

随着堆的不断增大（Full GC的代价更加昂贵），而G1 收集器易于避免这些问题的发生。

* 其他的考虑
Throughout 是年代最久远的，也是最成熟的，它的习性更为大家熟知。
G1 相对较新，更易碰到设计无法预期的极端情况。

相对而言 G1 中影响性能的调优控制开关更少，这可能是好事，也可能是坏事。
直到Java 7u4，G1 都一直作为实验版本，它的一些调优特性直到 Java 7u10中才提供出来。
G1 性能的提升主要体现在Java 8 中。
G1 将来的工作可能会关注如果提高它在较小的堆上相对于CMS的性能。
```







